<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Y轴刻度对齐测试</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .chart-container {
            width: 800px;
            height: 400px;
            margin: 20px 0;
        }
        .info {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .test-case {
            border: 1px solid #ccc;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>Y轴刻度对齐测试</h1>
    
    <div class="info">
        <strong>测试目的：</strong>验证Y轴刻度间隔一致性和边界对齐<br>
        <strong>期望结果：</strong>所有刻度应该严格按照stepSize间隔，且对齐到0或5结尾
    </div>
    
    <!-- 测试用例1：stepSize = 0.5 -->
    <div class="test-case">
        <h3>测试用例1：stepSize = 0.5，数据范围 46.6-56.4</h3>
        <div class="chart-container">
            <canvas id="testChart1"></canvas>
        </div>
        <div id="info1"></div>
    </div>
    
    <!-- 测试用例2：stepSize = 0.1 -->
    <div class="test-case">
        <h3>测试用例2：stepSize = 0.1，数据范围 67.8-68.3</h3>
        <div class="chart-container">
            <canvas id="testChart2"></canvas>
        </div>
        <div id="info2"></div>
    </div>
    
    <!-- 测试用例3：stepSize = 0.05 -->
    <div class="test-case">
        <h3>测试用例3：stepSize = 0.05，数据范围 55.1-55.9</h3>
        <div class="chart-container">
            <canvas id="testChart3"></canvas>
        </div>
        <div id="info3"></div>
    </div>

    <script>
        // 新的边界对齐逻辑（与修复后的代码一致）
        function calculateAlignedBounds(dataMin, dataMax, stepSize) {
            // 步骤1：将边界对齐到stepSize的倍数
            let alignedMin = Math.floor(dataMin / stepSize) * stepSize;
            let alignedMax = Math.ceil(dataMax / stepSize) * stepSize;
            
            // 步骤2：确保对齐到0或5结尾（仅当stepSize < 1时需要）
            if (stepSize < 1) {
                function alignTo05End(value, isMin) {
                    const rounded = Math.round(value * 100) / 100;
                    const lastDigit = Math.abs(Math.round(rounded * 100)) % 10;
                    
                    if (lastDigit === 0 || lastDigit === 5) {
                        return rounded;
                    }
                    
                    // 找到最近的0或5结尾值
                    const base = Math.floor(rounded * 10) / 10;
                    const option1 = base; // .0结尾
                    const option2 = base + 0.05; // .05结尾
                    
                    if (isMin) {
                        // 最小值：选择不大于原值的最大选项
                        return option2 <= value ? option2 : option1;
                    } else {
                        // 最大值：选择不小于原值的最小选项
                        return option1 >= value ? option1 : option2;
                    }
                }
                
                alignedMin = Math.max(0, alignTo05End(alignedMin, true));
                alignedMax = alignTo05End(alignedMax, false);
                
                // 重新确保对齐到stepSize的倍数
                alignedMin = Math.floor(alignedMin / stepSize) * stepSize;
                alignedMax = Math.ceil(alignedMax / stepSize) * stepSize;
            }
            
            // 步骤3：确保最小显示范围
            if (alignedMax - alignedMin < stepSize * 2) {
                const center = (alignedMin + alignedMax) / 2;
                alignedMin = Math.floor((center - stepSize) / stepSize) * stepSize;
                alignedMax = Math.ceil((center + stepSize) / stepSize) * stepSize;
                
                // 确保最小值不小于0
                alignedMin = Math.max(0, alignedMin);
            }
            
            return {
                min: Math.max(0, alignedMin),
                max: alignedMax
            };
        }
        
        // 创建测试图表
        function createTestChart(canvasId, infoId, dataRange, expectedStepSize, testName) {
            const ctx = document.getElementById(canvasId);
            const { min: dataMin, max: dataMax } = dataRange;
            
            // 模拟数据
            const testData = [];
            for (let i = 0; i < 10; i++) {
                testData.push(dataMin + (dataMax - dataMin) * i / 9);
            }
            
            const bounds = calculateAlignedBounds(dataMin, dataMax, expectedStepSize);
            
            console.log(`${testName} - 边界计算结果:`, {
                dataRange: `${dataMin} - ${dataMax}`,
                stepSize: expectedStepSize,
                bounds: `${bounds.min} - ${bounds.max}`,
                range: bounds.max - bounds.min,
                steps: Math.round((bounds.max - bounds.min) / expectedStepSize)
            });
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 10}, (_, i) => `时间${i}`),
                    datasets: [{
                        label: '剩余电量 (度)',
                        data: testData,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: bounds.min,
                            max: bounds.max,
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: '剩余电量 (度)'
                            },
                            ticks: {
                                stepSize: expectedStepSize,
                                includeBounds: true,
                                callback: function(value) {
                                    // 改进的刻度显示逻辑
                                    const rounded = Math.round(value * 100) / 100;
                                    
                                    // 检查是否是有效的刻度点（stepSize的倍数）
                                    const stepMultiple = Math.round(rounded / expectedStepSize);
                                    const expectedValue = stepMultiple * expectedStepSize;
                                    const diff = Math.abs(rounded - expectedValue);
                                    
                                    // 如果不是stepSize的倍数，不显示
                                    if (diff > 0.001) {
                                        return null;
                                    }
                                    
                                    // 检查是否符合0或5结尾的要求（仅当stepSize < 1时）
                                    if (expectedStepSize < 1) {
                                        const lastDigit = Math.abs(Math.round(rounded * 100)) % 10;
                                        if (lastDigit !== 0 && lastDigit !== 5) {
                                            return null;
                                        }
                                    }
                                    
                                    // 格式化显示
                                    if (expectedStepSize >= 1) {
                                        return rounded.toFixed(0);
                                    } else if (expectedStepSize >= 0.1) {
                                        return rounded.toFixed(1);
                                    } else {
                                        return rounded.toFixed(2);
                                    }
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    }
                }
            });
            
            // 显示测试信息
            setTimeout(() => {
                const yScale = chart.scales.y;
                const actualTicks = yScale.ticks || [];
                const visibleTicks = actualTicks.filter(tick => tick.label !== null && tick.label !== undefined);
                
                const info = `
                    <h4>测试结果</h4>
                    <p><strong>数据范围：</strong> ${dataMin} - ${dataMax}</p>
                    <p><strong>期望stepSize：</strong> ${expectedStepSize}</p>
                    <p><strong>计算边界：</strong> ${bounds.min.toFixed(3)} - ${bounds.max.toFixed(3)}</p>
                    <p><strong>实际Y轴范围：</strong> ${yScale.min?.toFixed(3)} - ${yScale.max?.toFixed(3)}</p>
                    <p><strong>显示刻度数量：</strong> ${visibleTicks.length}</p>
                    <p><strong>刻度间隔一致性：</strong> ${checkTickConsistency(visibleTicks, expectedStepSize) ? '✅ 一致' : '❌ 不一致'}</p>
                `;
                
                document.getElementById(infoId).innerHTML = info;
            }, 100);
            
            return chart;
        }
        
        // 检查刻度间隔一致性
        function checkTickConsistency(ticks, expectedStepSize) {
            if (ticks.length < 2) return true;
            
            for (let i = 1; i < ticks.length; i++) {
                const diff = Math.abs(ticks[i].value - ticks[i-1].value);
                const expectedDiff = expectedStepSize;
                if (Math.abs(diff - expectedDiff) > 0.001) {
                    console.log(`刻度间隔不一致: ${ticks[i-1].value} -> ${ticks[i].value}, 差值: ${diff}, 期望: ${expectedDiff}`);
                    return false;
                }
            }
            return true;
        }
        
        // 创建测试用例
        document.addEventListener('DOMContentLoaded', () => {
            // 测试用例1：模拟原问题场景 (46.6-56.4, stepSize=0.5)
            createTestChart('testChart1', 'info1', {min: 46.6, max: 56.4}, 0.5, '测试1');
            
            // 测试用例2：较小范围 (67.8-68.3, stepSize=0.1)
            createTestChart('testChart2', 'info2', {min: 67.8, max: 68.3}, 0.1, '测试2');
            
            // 测试用例3：最小步长 (55.1-55.9, stepSize=0.05)
            createTestChart('testChart3', 'info3', {min: 55.1, max: 55.9}, 0.05, '测试3');
        });
    </script>
</body>
</html>
